# Домашнее задание №4: Асинхронное межсервисное взаимодействие (Microservices E-Commerce)

**Выполнил:** Загоруйко Даниил
**Группа:** БПИ247
---

## Описание проекта

Реализация системы обработки заказов интернет-магазина на основе микросервисной архитектуры. Взаимодействие между сервисами происходит асинхронно через брокер сообщений Apache Kafka. Реализованы паттерны надежности для обеспечения целостности данных (Transaction Outbox/Inbox).

## Технологический стек

* **Язык:** Java 21 (Eclipse Temurin)
* **Фреймворк:** Spring Boot 3.2
* **База данных:** PostgreSQL 15 (отдельные БД для каждого сервиса)
* **Брокер сообщений:** Apache Kafka (+ Zookeeper)
* **API Documentation:** Swagger (OpenAPI)
* **Контейнеризация:** Docker, Docker Compose
* **Frontend:** HTML/JS + WebSocket (SockJS, STOMP) для Push-уведомлений

## Документация API
После запуска системы интерактивная документация доступна по адресам:
* **Order Service API:** [http://127.0.0.1:8080/swagger-ui/index.html](http://127.0.0.1:8080/swagger-ui/index.html)
* **Payment Service API:** [http://127.0.0.1:8081/swagger-ui/index.html](http://127.0.0.1:8081/swagger-ui/index.html)

## Архитектура и Сервисы

Система состоит из двух основных микросервисов:

### 1. Order Service (`:8080`)
* **Ответственность:** Создание заказов, хранение истории, обновление статусов.
* **Паттерны:** Transactional Outbox (события сначала пишутся в БД, потом отправляются в Kafka).
* **WebSocket:** Рассылает уведомления клиенту в реальном времени при изменении статуса заказа (например, после оплаты).

### 2. Payment Service (`:8081`)
* **Ответственность:** Управление счетами (Account), пополнение баланса, транзакции списания.
* **Паттерны:**
    * **Transactional Inbox:** Дедупликация входящих сообщений (идемпотентность) через таблицу `inbox_events`.
    * **Transactional Outbox:** Гарантированная отправка результата обработки.
    * **Optimistic Locking:** Защита баланса от "гонки" (race condition) при одновременных запросах.

---

## Инструкция по запуску

Для запуска необходимы **Docker** и **Docker Compose**.

1.  **Сборка и запуск контейнеров:**
    ```bash
    docker-compose up --build
    ```
    *(Ожидайте сообщения `Started App` в логах обоих сервисов).*

2.  **Остановка:**
    ```bash
    docker-compose down
    ```

---

## Тестирование (Сценарии)

### 1. Мониторинг (Frontend)
Откройте в браузере страницу для получения уведомлений:
**http://127.0.0.1:8080/index.html**

### 2. Успешная покупка (Happy Path)

**Шаг 1: Пополнить баланс пользователя (UserId=1)**
```bash
curl -X POST "[http://127.0.0.1:8081/accounts?userId=1&amount=1000](http://127.0.0.1:8081/accounts?userId=1&amount=1000)"

```

**Шаг 2: Создать заказ (на сумму 500)**

```bash
curl -X POST "[http://127.0.0.1:8080/orders?userId=1&amount=500](http://127.0.0.1:8080/orders?userId=1&amount=500)"

```

* **Результат:** Статус заказа меняется на `FINISHED`. В браузере всплывает уведомление **"УРА! Заказ оплачен!"**.

### 3. Недостаточно средств (Cancel Path)

**Шаг 1: Попытка заказа на сумму больше баланса**

```bash
curl -X POST "[http://127.0.0.1:8080/orders?userId=1&amount=9999](http://127.0.0.1:8080/orders?userId=1&amount=9999)"

```

* **Результат:** Статус заказа меняется на `CANCELLED`. В браузере всплывает уведомление **"Оплата не прошла :("**.

---

## Поток данных (Data Flow)

1. Клиент делает `POST /orders`.
2. `Order Service` сохраняет заказ (status=NEW) и событие в `outbox_events` (одна транзакция).
3. `Order Service` отправляет событие в Kafka (`payment-requests`).
4. `Payment Service` читает Kafka -> проверяет дубликат (Inbox) -> списывает средства -> сохраняет результат в свой `outbox`.
5. `Payment Service` отправляет результат в Kafka (`payment-results`).
6. `Order Service` читает результат -> обновляет статус заказа -> отправляет Push в WebSocket.
